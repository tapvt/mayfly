<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../../doc/otp_doc.css" type="text/css">
<title>Erlang -- Inet configuration</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../../doc/js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../../doc/js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../../../doc/erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="index.html">Reference Manual</a><br><a href="release_notes.html">Release Notes</a><br><a href="../pdf/erts-5.9.pdf">PDF</a><br><a href="../../../doc/index.html">Top</a></small><p><strong>Erlang Run-Time System Application (ERTS)</strong><br><strong>User's Guide</strong><br><small>Version 5.9</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagepath="../../../doc/js/flipmenu">
<li id="no" title="Match specifications in Erlang" expanded="false">Match specifications in Erlang<ul>
<li><a href="match_spec.html">
              Top of chapter
            </a></li>
<li title="Grammar"><a href="match_spec.html#id69857">Grammar</a></li>
<li title="Function descriptions"><a href="match_spec.html#id65696">Function descriptions</a></li>
<li title="Variables and literals"><a href="match_spec.html#id73277">Variables and literals</a></li>
<li title="Execution of the match"><a href="match_spec.html#id72196">Execution of the match</a></li>
<li title="Differences between match specifications in ETS and tracing"><a href="match_spec.html#id72576">Differences between match specifications in ETS and tracing</a></li>
<li title="Examples"><a href="match_spec.html#id72377">Examples</a></li>
</ul>
</li>
<li id="no" title="How to interpret the Erlang crash dumps" expanded="false">How to interpret the Erlang crash dumps<ul>
<li><a href="crash_dump.html">
              Top of chapter
            </a></li>
<li title="General information"><a href="crash_dump.html#id73103">General information</a></li>
<li title="Memory information"><a href="crash_dump.html#id71036">Memory information</a></li>
<li title="Internal table information"><a href="crash_dump.html#id71062">Internal table information</a></li>
<li title="Allocated areas"><a href="crash_dump.html#id71087">Allocated areas</a></li>
<li title="Allocator"><a href="crash_dump.html#id71113">Allocator</a></li>
<li title="Process information"><a href="crash_dump.html#id70712">Process information</a></li>
<li title="Port information"><a href="crash_dump.html#id72876">Port information</a></li>
<li title="ETS tables"><a href="crash_dump.html#id72893">ETS tables</a></li>
<li title="Timers"><a href="crash_dump.html#id72991">Timers</a></li>
<li title="Distribution information"><a href="crash_dump.html#id77060">Distribution information</a></li>
<li title="Loaded module information"><a href="crash_dump.html#id77183">Loaded module information</a></li>
<li title="Fun information"><a href="crash_dump.html#id77274">Fun information</a></li>
<li title="Process Data"><a href="crash_dump.html#id77346">Process Data</a></li>
<li title="Atoms"><a href="crash_dump.html#id77422">Atoms</a></li>
<li title="Disclaimer"><a href="crash_dump.html#id77438">Disclaimer</a></li>
</ul>
</li>
<li id="no" title="How to implement an alternative carrier for  the Erlang distribution" expanded="false">How to implement an alternative carrier for  the Erlang distribution<ul>
<li><a href="alt_dist.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="alt_dist.html#id77558">Introduction</a></li>
<li title="The driver"><a href="alt_dist.html#id77648">The driver</a></li>
<li title="Putting it all together"><a href="alt_dist.html#id78898">Putting it all together</a></li>
</ul>
</li>
<li id="no" title="The Abstract Format" expanded="false">The Abstract Format<ul>
<li><a href="absform.html">
              Top of chapter
            </a></li>
<li title="Module declarations and forms"><a href="absform.html#id79178">Module declarations and forms</a></li>
<li title="Atomic literals"><a href="absform.html#id79386">Atomic literals</a></li>
<li title="Patterns"><a href="absform.html#id79448">Patterns</a></li>
<li title="Expressions"><a href="absform.html#id79662">Expressions</a></li>
<li title="Clauses"><a href="absform.html#id80370">Clauses</a></li>
<li title="Guards"><a href="absform.html#id80590">Guards</a></li>
<li title="The abstract format after preprocessing"><a href="absform.html#id80865">The abstract format after preprocessing</a></li>
</ul>
</li>
<li id="no" title="tty - A command line interface" expanded="false">tty - A command line interface<ul>
<li><a href="tty.html">
              Top of chapter
            </a></li>
<li title="Normal Mode"><a href="tty.html#id81038">Normal Mode</a></li>
<li title="Shell Break Mode"><a href="tty.html#id81421">Shell Break Mode</a></li>
</ul>
</li>
<li id="no" title="How to implement a driver" expanded="false">How to implement a driver<ul>
<li><a href="driver.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="driver.html#id81546">Introduction</a></li>
<li title="Sample driver"><a href="driver.html#id81578">Sample driver</a></li>
<li title="Compiling and linking the sample driver"><a href="driver.html#id81980">Compiling and linking the sample driver</a></li>
<li title="Calling a driver as a port in Erlang"><a href="driver.html#id82017">Calling a driver as a port in Erlang</a></li>
<li title="Sample asynchronous driver"><a href="driver.html#id82124">Sample asynchronous driver</a></li>
<li title="An asynchronous driver using driver_async"><a href="driver.html#id82397">An asynchronous driver using driver_async</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Inet configuration" expanded="true">Inet configuration<ul>
<li><a href="inet_cfg.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="inet_cfg.html#id82662">Introduction</a></li>
<li title="Configuration Data"><a href="inet_cfg.html#id82765">Configuration Data</a></li>
<li title="User Configuration Example"><a href="inet_cfg.html#id83642">User Configuration Example</a></li>
</ul>
</li>
<li id="no" title="External Term Format" expanded="false">External Term Format<ul>
<li><a href="erl_ext_dist.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="erl_ext_dist.html#id83743">Introduction</a></li>
<li title="Distribution header"><a href="erl_ext_dist.html#id84023">Distribution header</a></li>
<li title="ATOM_CACHE_REF"><a href="erl_ext_dist.html#id84596">ATOM_CACHE_REF</a></li>
<li title="SMALL_INTEGER_EXT"><a href="erl_ext_dist.html#id84672">SMALL_INTEGER_EXT</a></li>
<li title="INTEGER_EXT"><a href="erl_ext_dist.html#id84735">INTEGER_EXT</a></li>
<li title="FLOAT_EXT"><a href="erl_ext_dist.html#id84799">FLOAT_EXT</a></li>
<li title="ATOM_EXT"><a href="erl_ext_dist.html#id84875">ATOM_EXT</a></li>
<li title="REFERENCE_EXT"><a href="erl_ext_dist.html#id84970">REFERENCE_EXT</a></li>
<li title="PORT_EXT"><a href="erl_ext_dist.html#id85128">PORT_EXT</a></li>
<li title="PID_EXT"><a href="erl_ext_dist.html#id85247">PID_EXT</a></li>
<li title="SMALL_TUPLE_EXT"><a href="erl_ext_dist.html#id85391">SMALL_TUPLE_EXT</a></li>
<li title="LARGE_TUPLE_EXT"><a href="erl_ext_dist.html#id85483">LARGE_TUPLE_EXT</a></li>
<li title="NIL_EXT"><a href="erl_ext_dist.html#id85573">NIL_EXT</a></li>
<li title="STRING_EXT"><a href="erl_ext_dist.html#id85624">STRING_EXT</a></li>
<li title="LIST_EXT"><a href="erl_ext_dist.html#id85717">LIST_EXT</a></li>
<li title="BINARY_EXT"><a href="erl_ext_dist.html#id85835">BINARY_EXT</a></li>
<li title="SMALL_BIG_EXT"><a href="erl_ext_dist.html#id85932">SMALL_BIG_EXT</a></li>
<li title="LARGE_BIG_EXT"><a href="erl_ext_dist.html#id86039">LARGE_BIG_EXT</a></li>
<li title="NEW_REFERENCE_EXT"><a href="erl_ext_dist.html#id86142">NEW_REFERENCE_EXT</a></li>
<li title="SMALL_ATOM_EXT"><a href="erl_ext_dist.html#id86315">SMALL_ATOM_EXT</a></li>
<li title="FUN_EXT"><a href="erl_ext_dist.html#id86421">FUN_EXT</a></li>
<li title="NEW_FUN_EXT"><a href="erl_ext_dist.html#id86668">NEW_FUN_EXT</a></li>
<li title="EXPORT_EXT"><a href="erl_ext_dist.html#id87045">EXPORT_EXT</a></li>
<li title="BIT_BINARY_EXT"><a href="erl_ext_dist.html#id87189">BIT_BINARY_EXT</a></li>
<li title="NEW_FLOAT_EXT"><a href="erl_ext_dist.html#id87295">NEW_FLOAT_EXT</a></li>
</ul>
</li>
<li id="no" title="Distribution Protocol" expanded="false">Distribution Protocol<ul>
<li><a href="erl_dist_protocol.html">
              Top of chapter
            </a></li>
<li title="EPMD Protocol"><a href="erl_dist_protocol.html#id87472">EPMD Protocol</a></li>
<li title="Handshake"><a href="erl_dist_protocol.html#id88770">Handshake</a></li>
<li title="Protocol between connected nodes"><a href="erl_dist_protocol.html#id88786">Protocol between connected nodes</a></li>
<li title="New Ctrlmessages for distrvsn = 1 (OTP R4)"><a href="erl_dist_protocol.html#id89228">New Ctrlmessages for distrvsn = 1 (OTP R4)</a></li>
<li title="New Ctrlmessages for distrvsn = 2"><a href="erl_dist_protocol.html#id89327">New Ctrlmessages for distrvsn = 2</a></li>
<li title="New Ctrlmessages for distrvsn = 3 (OTP R5C)"><a href="erl_dist_protocol.html#id89338">New Ctrlmessages for distrvsn = 3 (OTP R5C)</a></li>
<li title="New Ctrlmessages for distrvsn = 4 (OTP R6)"><a href="erl_dist_protocol.html#id89350">New Ctrlmessages for distrvsn = 4 (OTP R6)</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>7 Inet configuration</h1>
  

  <h3><a name="id82662">7.1 
        Introduction</a></h3>
    
    <p>This chapter tells you how the Erlang runtime system is configured
      for IP communication. It also explains how you may configure it 
      for your own particular needs by means of a configuration file.
      The information here is mainly intended for users with special 
      configuration needs or problems. There should normally be no need
      for specific settings for Erlang to function properly on a correctly 
      IP configured platform.      </p>
    <p>When Erlang starts up it will read the kernel variable 
      <span class="code">inetrc</span> which, if defined, should specify the location and 
      name of a user configuration file. Example:</p>
    <p><span class="code">% erl -kernel inetrc '"./cfg_files/erl_inetrc"'</span></p>
    <p>Note that the usage of a <span class="code">.inetrc</span> file, which was
      supported in earlier Erlang versions, is now obsolete.</p>
    <p>A second way to specify the configuration file is to set the
      environment variable <span class="code">ERL_INETRC</span> to the full name of the file. Example (bash):</p>
    <p><span class="code">% export ERL_INETRC=./cfg_files/erl_inetrc</span></p>
    <p>Note that the kernel variable <span class="code">inetrc</span> overrides this environment variable.</p>
    <p>If no user configuration file is specified and Erlang is started
      in non-distributed or short name distributed mode, Erlang will use 
      default configuration settings and a native lookup method that should 
      work correctly under most circumstances. Erlang 
      will not read any information from system inet configuration files 
      (like /etc/host.conf, /etc/nsswitch.conf, etc) in these modes,
      except for /etc/resolv.conf and /etc/hosts that is read and monitored
      for changes on Unix platforms for the internal DNS client
      <span class="bold_code"><a href="javascript:erlhref('../../../doc/../','kernel','inet_res.html');">inet_res</a></span>.</p>
    <p>If Erlang is started in long name distributed mode, it needs to
      get the domain name from somewhere and will read system inet
      configuration files for this information. Any hosts and resolver
      information found then is also recorded, but not 
      used as long as Erlang is configured for native lookups. (The
      information becomes useful if the lookup method is changed to 
      <span class="code">'file'</span> or <span class="code">'dns'</span>, see below).</p>
    <p>Native lookup (system calls) is always the default resolver method. This
      is true for all platforms except VxWorks and OSE Delta where <span class="code">'file'</span> 
      or <span class="code">'dns'</span> is used (in that order of priority).</p>
    <p>On Windows platforms, Erlang will search the system registry rather than
      look for configuration files when started in long name distributed mode. </p>
  

  <h3><a name="id82765">7.2 
        Configuration Data</a></h3>
    
    <p>Erlang records the following data in a local database if found in system 
      inet configuration files (or system registry):</p>
    <ul>
      <li>Host names and addresses</li>
      <li>Domain name</li>
      <li>Nameservers</li>
      <li>Search domains</li>
      <li>Lookup method</li>
    </ul>
    <p>This data may also be specified explicitly in the user
      configuration file. The configuration file should contain lines
      of configuration parameters (each terminated with a full
      stop). Some parameters add data to the configuration (e.g. host
      and nameserver), others overwrite any previous settings
      (e.g. domain and lookup). The user configuration file is always
      examined last in the configuration process, making it possible
      for the user to override any default values or previously made
      settings. Call <span class="code">inet:get_rc()</span> to view the state of the
      inet configuration database.</p>
    <p>These are the valid configuration parameters:</p>
    <p></p>
    <dl>
      <dt><strong><strong><span class="code">{file, Format, File}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">Format = atom()</span></p>
        <p><span class="code">File = string()</span></p>
        <p></p>
        <p>Specify a system file that Erlang should read configuration
          data from. <span class="code">Format</span> tells the parser how the file should be
          interpreted: <span class="code">resolv</span> (Unix resolv.conf), <span class="code">host_conf_freebsd</span> 
          (FreeBSD host.conf), <span class="code">host_conf_bsdos</span> (BSDOS host.conf), 
          <span class="code">host_conf_linux</span> (Linux host.conf), <span class="code">nsswitch_conf</span>
          (Unix nsswitch.conf) or <span class="code">hosts</span> (Unix hosts). <span class="code">File</span> should
          specify the name of the file with full path.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{resolv_conf, File}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">File = string()</span></p>
        <p></p>
        <p>Specify a system file that Erlang should read resolver
          configuration from for the internal DNS client
          <span class="bold_code"><a href="javascript:erlhref('../../../doc/../','kernel','inet_res.html');">inet_res</a></span>,
          and monitor for changes, even if it does not exist.
          The path must be absolute.</p>
        <p>This may override the configuration parameters
          <span class="code">nameserver</span> and
          <span class="code">search</span> depending on the contents
          of the specified file. They may also change any time in the future
          reflecting the file contents.</p>
        <p>If the file is specified as an empty string "",
          no file is read nor monitored in the future. This emulates
          the old behaviour of not configuring the DNS client when
          the node is started in short name distributed mode.</p>
        <p>If this parameter is not specified it defaults to
          <span class="code">/etc/resolv.conf</span> unless the environment variable
          <span class="code">ERL_INET_ETC_DIR</span> is set which defines
          the directory for this file to some maybe other than
          <span class="code">/etc</span>.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{hosts_file, File}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">File = string()</span></p>
        <p></p>
        <p>Specify a system file that Erlang should read resolver
          configuration from for the internal hosts file resolver
          and monitor for changes, even if it does not exist.
          The path must be absolute.</p>
        <p>These host entries are searched after all added with
          <span class="code">{file, hosts, File}</span> above or
          <span class="code">{host, IP, Aliases}</span> below when the lookup option
          <span class="code">file</span> is used.</p>
        <p>If the file is specified as an empty string "",
          no file is read nor monitored in the future. This emulates
          the old behaviour of not configuring the DNS client when
          the node is started in short name distributed mode.</p>
        <p>If this parameter is not specified it defaults to
          <span class="code">/etc/hosts</span> unless the environment variable
          <span class="code">ERL_INET_ETC_DIR</span> is set which defines
          the directory for this file to some maybe other than
          <span class="code">/etc</span>.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{registry, Type}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">Type = atom()</span></p>
        <p></p>
        <p>Specify a system registry that Erlang should read configuration
          data from. Currently, <span class="code">win32</span> is the only valid option.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{host, IP, Aliases}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">IP = tuple()</span></p>
        <p><span class="code">Aliases = [string()]</span></p>
        <p></p>
        <p>Add host entry to the hosts table.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{domain, Domain}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">Domain = string()</span></p>
        <p></p>
        <p>Set domain name.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{nameserver, IP [,Port]}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">IP = tuple()</span></p>
        <p><span class="code">Port = integer()</span></p>
        <p></p>
        <p>Add address (and port, if other than default) of primary 
          nameserver to use for
         <span class="bold_code"><a href="javascript:erlhref('../../../doc/../','kernel','inet_res.html');">inet_res</a></span>.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{alt_nameserver, IP [,Port]}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">IP = tuple()</span></p>
        <p><span class="code">Port = integer()</span></p>
        <p></p>
        <p>Add address (and port, if other than default) of secondary 
          nameserver for
         <span class="bold_code"><a href="javascript:erlhref('../../../doc/../','kernel','inet_res.html');">inet_res</a></span>.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{search, Domains}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">Domains = [string()]</span></p>
        <p></p>
        <p>Add search domains for
         <span class="bold_code"><a href="javascript:erlhref('../../../doc/../','kernel','inet_res.html');">inet_res</a></span>.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{lookup, Methods}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">Methods = [atom()]</span></p>
        <p></p>
        <p>Specify lookup methods and in which order to try them. 
          The valid methods are: <span class="code">native</span> (use system calls),
          <span class="code">file</span> (use host data retrieved from
          system configuration files and/or 
          the user configuration file) or <span class="code">dns</span>
          (use the Erlang DNS client
          <span class="bold_code"><a href="javascript:erlhref('../../../doc/../','kernel','inet_res.html');">inet_res</a></span>
          for nameserver queries).</p>
	<p>The lookup method <span class="code">string</span> tries to
	  parse the hostname as a IPv4 or IPv6 string and return
	  the resulting IP address. It is automatically tried
	  first when <span class="code">native</span> is <strong>not</strong>
	  in the <span class="code">Methods</span> list. To skip it in this case
	  the pseudo lookup method <span class="code">nostring</span> can be
	  inserted anywhere in the <span class="code">Methods</span> list.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{cache_size, Size}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">Size = integer()</span></p>
        <p></p>
        <p>Set size of resolver cache. Default is 100 DNS records.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{cache_refresh, Time}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">Time = integer()</span></p>
        <p></p>
        <p>Set how often (in millisec)
          the resolver cache for
          <span class="bold_code"><a href="javascript:erlhref('../../../doc/../','kernel','inet_res.html');">inet_res</a></span>.
          is refreshed (i.e. expired DNS records are deleted).
          Default is 1 h.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{timeout, Time}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">Time = integer()</span></p>
        <p></p>
        <p>Set the time to wait until retry (in millisec) for DNS queries
          made by
          <span class="bold_code"><a href="javascript:erlhref('../../../doc/../','kernel','inet_res.html');">inet_res</a></span>.
          Default is 2 sec.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{retry, N}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">N = integer()</span></p>
        <p></p>
        <p>Set the number of DNS queries
          <span class="bold_code"><a href="javascript:erlhref('../../../doc/../','kernel','inet_res.html');">inet_res</a></span>
          will try before giving up.
          Default is 3.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{inet6, Bool}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">Bool = true | false</span></p>
        <p></p>
        <p>Tells the DNS client 
          <span class="bold_code"><a href="javascript:erlhref('../../../doc/../','kernel','inet_res.html');">inet_res</a></span>
          to look up IPv6 addresses. Default is false.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{usevc, Bool}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">Bool = true | false</span></p>
        <p></p>
        <p>Tells the DNS client 
          <span class="bold_code"><a href="javascript:erlhref('../../../doc/../','kernel','inet_res.html');">inet_res</a></span>
          to use TCP (Virtual Circuit) instead of UDP. Default is false.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{edns, Version}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">Version = false | 0</span></p>
        <p></p>
        <p>Sets the EDNS version that
          <span class="bold_code"><a href="javascript:erlhref('../../../doc/../','kernel','inet_res.html');">inet_res</a></span>
          will use. The only allowed is zero. Default is false
          which means to not use EDNS.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{udp_payload_size, Size}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">N = integer()</span></p>
        <p></p>
        <p>Sets the allowed UDP payload size
          <span class="bold_code"><a href="javascript:erlhref('../../../doc/../','kernel','inet_res.html');">inet_res</a></span>
          will advertise in EDNS queries. Also sets the limit
          when the DNS query will be deemed too large for UDP
          forcing a TCP query instead, which is not entirely
          correct since the advertised UDP payload size of the
          individual nameserver is what should be used,
          but this simple strategy will do until a more intelligent
          (probing, caching) algorithm need be implemented.
          The default is 1280 which stems from the
          standard Ethernet MTU size.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{udp, Module}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">Module = atom()</span></p>
        <p></p>
        <p>Tell Erlang to use other primitive UDP module than inet_udp.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">{tcp, Module}.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p><span class="code">Module = atom()</span></p>
        <p></p>
        <p>Tell Erlang to use other primitive TCP module than inet_tcp.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">clear_hosts.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p>Clear the hosts table.</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">clear_ns.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p>Clear the list of recorded nameservers (primary and secondary).</p>
        <p></p>
      </dd>
      <dt><strong><strong><span class="code">clear_search.</span></strong></strong></dt>
      <dd>
        <p></p>
        <p>Clear the list of search domains.</p>
        <p></p>
      </dd>
    </dl>
  

  <h3><a name="id83642">7.3 
        User Configuration Example</a></h3>
    
    <p>Here follows a user configuration example.</p>
    <p>Assume a user does not want Erlang to use the native lookup method, 
      but wants Erlang to read all information necessary from start and use 
      that for resolving names and addresses. In case lookup fails, Erlang 
      should request the data from a nameserver (using the Erlang 
      DNS client, set to use EDNS allowing larger responses).
      The resolver configuration will be updated when
      its configuration file changes, furthermore, DNS records
      should never be cached. The user configuration file
      (in this example named <span class="code">erl_inetrc</span>, stored
      in directory <span class="code">./cfg_files</span>) could then look like this 
      (Unix):</p>
    <div class="example"><pre>
      %% -- ERLANG INET CONFIGURATION FILE --
      %% read the hosts file
      {file, hosts, "/etc/hosts"}.
      %% add a particular host
      {host, {134,138,177,105}, ["finwe"]}.
      %% do not monitor the hosts file
      {hosts_file, ""}.
      %% read and monitor nameserver config from here
      {resolv_conf, "/usr/local/etc/resolv.conf"}.
      %% enable EDNS
      {edns,0}.
      %% disable caching
      {cache_size, 0}.
      %% specify lookup method
      {lookup, [file, dns]}.</pre></div>
    <p>And Erlang could, for example, be started like this:</p>
    <p><span class="code">% erl -sname my_node -kernel inetrc '"./cfg_files/erl_inetrc"'</span></p>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2011 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
